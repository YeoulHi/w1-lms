# Task 002-001: 수강신청 버튼 통합 및 QA

## 1. 목표

spec-002 "코스 수강신청" 기능의 프론트엔드 통합 및 QA를 완료한다.

## 2. 현황 분석

### 완료된 구현
- ✅ Backend API (`POST /api/enrollments`)
- ✅ Service Layer (`enrollInCourseService`)
- ✅ React Query Hook (`useEnrollInCourse`)
- ✅ UI Component (`EnrollButton`)

### 미완료 항목
- ❌ 코스 상세 페이지에 `EnrollButton` 통합
- ❌ 테스트용 published 코스 데이터 부재
- ❌ QA 시나리오 검증

## 3. 구현 계획

### 3.1. 테스트 데이터 생성

**목적**: QA를 위한 published 상태 코스 생성

**방법**: Supabase SQL Editor에서 직접 실행

```sql
-- 1. Instructor 프로필 확인 (없으면 생성)
INSERT INTO profiles (id, role, name, phone_number)
VALUES (
  'f47ac10b-58cc-4372-a567-0e02b2c3d479'::uuid,  -- 임시 UUID
  'instructor',
  '테스트 강사',
  '010-1234-5678'
)
ON CONFLICT (id) DO NOTHING;

-- 2. Published 코스 생성
INSERT INTO courses (id, instructor_id, title, description, status)
VALUES (
  gen_random_uuid(),
  'f47ac10b-58cc-4372-a567-0e02b2c3d479'::uuid,
  'Next.js 15 마스터 클래스',
  'App Router, Server Actions, React Server Components를 마스터합니다.',
  'published'
);

-- 3. 생성된 코스 확인
SELECT id, title, status, instructor_id
FROM courses
WHERE status = 'published';
```

**대안**: 이미 등록된 instructor가 있다면 해당 `id`를 사용

```sql
-- 기존 instructor 조회
SELECT id, name FROM profiles WHERE role = 'instructor' LIMIT 1;

-- 위 결과의 id를 사용하여 코스 생성
INSERT INTO courses (instructor_id, title, description, status)
VALUES (
  '{instructor_id}'::uuid,  -- 조회된 instructor id로 교체
  'TypeScript 심화 과정',
  'Type-safe 백엔드 API 설계와 Zod 스키마 활용법을 배웁니다.',
  'published'
);
```

### 3.2. 코스 상세 페이지 통합

**파일**: `src/app/courses/[id]/page.tsx` (신규 생성 필요시)

**구현 요구사항**:
- Server Component에서 코스 정보 조회
- `EnrollButton` 컴포넌트 임포트 및 배치
- 코스 상태가 `published`일 때만 버튼 표시

**예상 코드**:
```tsx
// src/app/courses/[id]/page.tsx
import { EnrollButton } from '@/features/enrollments/components/EnrollButton';

export default async function CoursePage({
  params
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params;
  // TODO: 코스 정보 조회 로직 추가

  return (
    <div>
      <h1>{/* 코스 제목 */}</h1>
      <p>{/* 코스 설명 */}</p>

      {/* 수강신청 버튼 */}
      <EnrollButton courseId={id} />
    </div>
  );
}
```

**최소 복잡도 원칙 적용**:
- 코스 조회 API가 없는 경우 **일단 하드코딩으로 진행**
- 에러 핸들링은 API 레벨에서만 처리 (UI 단순화)
- 인증 체크는 미들웨어/백엔드에 위임

## 4. QA 시나리오

### 준비사항
1. **DB 데이터 확인**
   ```sql
   SELECT * FROM courses WHERE status = 'published';
   ```
   - 결과가 없으면 3.1절의 SQL 실행

2. **Learner 계정 준비**
   - `/signup` 에서 신규 가입 (자동으로 learner 역할 부여)
   - 또는 기존 learner 계정 로그인

### 시나리오 1: 정상 수강신청

| 단계 | 경로 | 행동 | 기대 결과 |
|------|------|------|-----------|
| 1 | `/login` | Learner 로그인 | 대시보드 이동 |
| 2 | `/courses/{courseId}` | 코스 상세 페이지 접근 | "수강신청" 버튼 표시 |
| 3 | - | "수강신청" 버튼 클릭 | 버튼 비활성화 + "수강신청 중..." 표시 |
| 4 | - | API 응답 대기 | "수강신청 완료" 토스트 메시지 |
| 5 | Supabase | `enrollments` 테이블 확인 | 레코드 생성 확인 |

**검증 SQL**:
```sql
SELECT * FROM enrollments
WHERE learner_id = '{user_id}'
  AND course_id = '{course_id}';
```

### 시나리오 2: 중복 수강신청

| 단계 | 경로 | 행동 | 기대 결과 |
|------|------|------|-----------|
| 1 | - | 시나리오 1 완료 후 | - |
| 2 | `/courses/{courseId}` | 같은 코스 페이지 재방문 | "수강신청" 버튼 표시 (현재 구현) |
| 3 | - | "수강신청" 버튼 다시 클릭 | `409 Conflict` 에러 |
| 4 | - | - | "이미 수강 중인 코스입니다." 토스트 |

**예상 에러 응답**:
```json
{
  "ok": false,
  "error": {
    "code": "ENROLLMENT_ALREADY_EXISTS",
    "message": "이미 수강 중인 코스입니다."
  }
}
```

### 시나리오 3: 비로그인 사용자

| 단계 | 경로 | 행동 | 기대 결과 |
|------|------|------|-----------|
| 1 | - | 로그아웃 상태 | - |
| 2 | `/courses/{courseId}` | 코스 페이지 직접 접근 | 버튼 클릭 시 |
| 3 | - | "수강신청" 버튼 클릭 | `401 Unauthorized` 에러 |
| 4 | - | - | "인증되지 않은 사용자입니다." 토스트 |

**개선 가능**: 미들웨어에서 `/courses/*` 경로를 보호하여 로그인 페이지로 리다이렉트

## 5. 체크리스트

### 구현
- [ ] Supabase에 테스트 코스 데이터 생성 (published 상태)
- [ ] `/courses/[id]/page.tsx` 파일 존재 확인
- [ ] `EnrollButton` 컴포넌트 통합
- [ ] 개발 서버 재시작 (`npm run dev`)

### QA
- [ ] 시나리오 1: 정상 수강신청 성공
- [ ] 시나리오 2: 중복 신청 시 409 에러
- [ ] 시나리오 3: 비로그인 시 401 에러
- [ ] 쿠키 에러 해결 확인 (페이지 새로고침 반복)
- [ ] 네트워크 탭에서 `POST /api/enrollments` 응답 확인

### 선택사항 (우선순위 낮음)
- [ ] 이미 수강 중인 경우 버튼 텍스트를 "수강 중"으로 변경
- [ ] draft 코스에서는 버튼 미표시
- [ ] 수강신청 성공 후 코스 목록 페이지로 리다이렉트

## 6. 리스크 및 제약사항

### 현재 제약
1. **코스 조회 API 미구현**: 상세 페이지에서 코스 정보를 가져올 방법 없음
   - **해결책**: 임시로 하드코딩 또는 별도 spec에서 구현

2. **수강 상태 확인 미구현**: 버튼이 항상 "수강신청"으로 표시
   - **해결책**: 중복 신청은 백엔드에서 차단하므로 MVP로는 충분

3. **권한 체크 부재**: Instructor가 자기 코스를 신청할 수 있음
   - **해결책**: 현재 scope 외. 별도 spec에서 role 기반 UI 제어

### 최소 복잡도 준수
- ✅ 엣지 케이스 처리 생략 (spec 외)
- ✅ UI는 기본 상태만 표시
- ✅ 비즈니스 로직은 백엔드에만 집중

## 7. 완료 기준

1. ✅ published 코스가 DB에 최소 1개 존재
2. ✅ `/courses/{courseId}` 페이지에서 `EnrollButton` 렌더링
3. ✅ Learner 계정으로 수강신청 성공
4. ✅ `enrollments` 테이블에 레코드 생성 확인
5. ✅ 중복 신청 시 적절한 에러 메시지 표시
6. ✅ 쿠키 관련 에러 미발생

## 8. 참고 문서

- [docs/002/spec.md](./spec.md) - 기능 명세
- [docs/002/plan.md](./plan.md) - 구현 계획
- [docs/database.md](../database.md) - DB 스키마
- [.ruler/AGENTS.md](../../.ruler/AGENTS.md) - 개발 가이드라인
